import Docs from '../../../../components/Docs/Docs'

export default () => {
    return(
        <Docs>
            <div className="container">
            <h1>Быстрое обновление</h1>
<p>
<span className="spanTag">Fast Refresh</span> - это функция Next.js, которая дает вам мгновенную обратную связь об изменениях, внесенных в ваши компоненты React. Быстрое обновление включено по умолчанию во всех приложениях Next.js версии 9.4 или новее. При включенном Next.js <span className="spanTag">Fast Refresh</span> большинство изменений должны быть видны в течение секунды без потери состояния компонента.
</p>


<h2>Как это устроено</h2>
<p className='list'>
 - Если вы редактируете файл, который экспортирует только компоненты React, <span className="spanTag">Fast Refresh</span> обновит код только для этого файла и повторно отобразит ваш компонент. Вы можете редактировать что угодно в этом файле, включая стили, логику рендеринга, обработчики событий или эффекты.
</p>
<p className='list'>
 - Если вы редактируете файл с экспортом, который не является компонентом React, <span className="spanTag">Fast Refresh</span> повторно запустит как этот файл, так и другие файлы, импортирующие его. Таким образом, если оба <span className="spanTag">Button.js</span> и <span className="spanTag">Modal.js</span> импортировать в <span className="spanTag">theme.js</span>, редактирование <span className="spanTag">theme.js</span> обновит оба компонента.
</p>
<p className='list'>
 - Наконец, если вы отредактируете файл, импортированный файлами вне дерева React, <span className="spanTag">Fast Refresh</span> вернется к выполнению полной перезагрузки. У вас может быть файл, который отображает компонент React, но также экспортирует значение, которое импортируется не React компонентом. Например, возможно, ваш компонент также экспортирует константу, а служебный файл, не относящийся к React, импортирует ее. В этом случае рассмотрите возможность переноса константы в отдельный файл и ее импорта в оба файла. Это снова включит работу <span className="spanTag">Fast Refresh</span>. Остальные случаи обычно решаются аналогичным образом.
</p>

<h2>Устойчивость к ошибкам</h2>
<h3>Ошибки синтаксиса</h3>

Если вы допустили синтаксическую ошибку во время разработки, вы можете исправить ее и снова сохранить файл. Ошибка исчезнет автоматически, поэтому вам не нужно перезагружать приложение. Вы не потеряете состояние компонента.

<h3>Ошибки времени выполнения</h3>
<p>
Если вы сделаете ошибку, которая приведет к ошибке выполнения внутри вашего компонента, вас встретит контекстное наложение. При исправлении ошибки наложение автоматически закрывается без перезагрузки приложения.
</p>
<p>
Состояние компонента будет сохранено, если ошибка не возникла во время рендеринга. Если ошибка произошла во время рендеринга, React перемонтирует ваше приложение, используя обновленный код.
</p>
<p>
Если у вас есть границы ошибок в вашем приложении (что является хорошей идеей для постепенных сбоев в производстве), они будут повторять рендеринг при следующем редактировании после ошибки рендеринга. Это означает, что наличие границы ошибки может помешать вам всегда возвращаться в состояние корневого приложения. Однако имейте в виду, что границы ошибок не должны быть слишком детальными. Они используются React в производственной среде и всегда должны разрабатываться намеренно.
</p>

<h2>Ограничения</h2>
<p>
<span className="spanTag">Fast Refresh</span> пытается сохранить локальное состояние React в компоненте, который вы редактируете, но только если это безопасно. Вот несколько причин, по которым вы можете увидеть, что локальное состояние сбрасывается при каждом редактировании файла:
</p>
<p className='list'>
 - Локальное состояние не сохраняется для компонентов класса (только функциональные компоненты и хуки сохраняют состояние).
</p>
<p className='list'>
 - Файл, который вы редактируете, может иметь другие экспорты в дополнение к компоненту React.
</p>
<p className='list'>
 - Иногда файл экспортирует результат вызова компонента более высокого порядка, например <span className="spanTag">higherOrderComponent(WrappedComponent)</span>. Если возвращаемый компонент является классом, состояние будет сброшено.
</p>
<p className="list">
 - Анонимные стрелочные функции, например, <span className="spanTag">{`export default () => <div />`};</span> заставляют быстрое обновление не сохранять состояние локального компонента. Для больших кодовых баз вы можете использовать наш <span className="spanTag">name-default-componentcodemod</span>.
</p>
<p>
По мере того как большая часть вашей кодовой базы перемещается в функциональные компоненты и хуки, вы можете ожидать, что состояние будет сохранено в большем количестве случаев.
</p>

<h2>Подсказки</h2>
<p className='list'>
 - <span className="spanTag">Fast Refresh</span> по умолчанию сохраняет локальное состояние React в функциональных компонентах (и хуках).
</p>
<p className='list'>
 - Иногда вам может потребоваться принудительно сбросить состояние и перемонтировать компонент. Например, это может быть удобно, если вы настраиваете анимацию, которая происходит только при монтировании. Для этого вы можете добавить <span className="spanTag">// @refresh reset</span> в любое место редактируемого файла. Эта директива является локальной для файла и предписывает <span className="spanTag">Fast Refresh</span> перемонтировать компоненты, определенные в этом файле, при каждом редактировании.
</p>
<p className='list'>
 - Вы можете вставлять <span className="spanTag">console.log</span> или вставлять <span className="spanTag">debugger</span>; в компоненты, которые редактируете во время разработки.
</p>


<h2>Быстрое обновление и хуки</h2>
<p>
По возможности <span className="spanTag">Fast Refresh</span> пытается сохранить состояние вашего компонента между изменениями. В частности, <span className="spanTag">useState</span> и <span className="spanTag">useRef</span> сохраняют свои предыдущие значения до тех пор, пока вы не измените их аргументы или порядок вызова хуков.
</p>
<p>
Хуки с зависимостями, такие как <span className="spanTag">useEffect</span>, <span className="spanTag">useMemo</span> и <span className="spanTag">useCallback</span> - будут всегда обновлятся во время быстрого обновления. Их список зависимостей будет проигнорирован, пока происходит быстрое обновление.
</p>
<p>
Например, при редактировании <span className="spanTag">useMemo(() => x * 2, [x])</span>в <span className="spanTag">useMemo(() => x * 10, [x])</span>, он будет повторно запущен, даже если x (зависимость) не изменилась. Если бы React этого не делал, ваше редактирование не отражалось бы на экране!
</p>
<p>
Иногда это может привести к неожиданным результатам. Например, даже <span className="spanTag">useEffect</span> с пустым массивом зависимостей все равно будет повторно запускаться один раз во время быстрого обновления.
</p>
<p>
Однако написание кода, устойчивого к случайному повторному запуску <span className="spanTag">useEffect</span>, является хорошей практикой даже без <span className="spanTag">Fast Refresh</span>. Это упростит вам введение в него новых зависимостей позже, и это обеспечивается строгим режимом React, который мы настоятельно рекомендуем включить.
</p>
            </div>
        </Docs>
    )
}