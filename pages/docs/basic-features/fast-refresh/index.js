import Docs from '../../../../components/Docs/Docs'

export default () => {
    return(
        <Docs>
            <div className="container">
            <h1>Быстрое обновление</h1>
<p>
Fast Refresh - это функция Next.js, которая дает вам мгновенную обратную связь об изменениях, внесенных в ваши компоненты React. Быстрое обновление включено по умолчанию во всех приложениях Next.js версии 9.4 или новее. При включенном Next.js Fast Refresh большинство изменений должны быть видны в течение секунды без потери состояния компонента.
</p>


<h2>Как это устроено</h2>
<p className='list'>
 - Если вы редактируете файл, который экспортирует только компоненты React, Fast Refresh обновит код только для этого файла и повторно отобразит ваш компонент. Вы можете редактировать что угодно в этом файле, включая стили, логику рендеринга, обработчики событий или эффекты.
</p>
<p className='list'>
 - Если вы редактируете файл с экспортом, который не является компонентом React, Fast Refresh повторно запустит как этот файл, так и другие файлы, импортирующие его. Таким образом, если оба Button.js и Modal.js import theme.js, редактирование theme.jsобновит оба компонента.
</p>
<p className='list'>
 - Наконец, если вы отредактируете файл, импортированный файлами вне дерева React, Fast Refresh вернется к выполнению полной перезагрузки. У вас может быть файл, который отображает компонент React, но также экспортирует значение, которое импортируется не React компонентом. Например, возможно, ваш компонент также экспортирует константу, а служебный файл, не относящийся к React, импортирует ее. В этом случае рассмотрите возможность переноса константы в отдельный файл и ее импорта в оба файла. Это снова включит работу Fast Refresh. Остальные случаи обычно решаются аналогичным образом.
</p>

<h2>Устойчивость к ошибкам</h2>
<h3>Ошибки синтаксиса</h3>

Если вы допустили синтаксическую ошибку во время разработки, вы можете исправить ее и снова сохранить файл. Ошибка исчезнет автоматически, поэтому вам не нужно перезагружать приложение. Вы не потеряете состояние компонента .

<h3>Ошибки времени выполнения</h3>
<p>
Если вы сделаете ошибку, которая приведет к ошибке выполнения внутри вашего компонента, вас встретит контекстное наложение. При исправлении ошибки наложение автоматически закрывается без перезагрузки приложения.
</p>
<p>
Состояние компонента будет сохранено, если ошибка не возникла во время рендеринга. Если ошибка произошла во время рендеринга, React перемонтирует ваше приложение, используя обновленный код.
</p>
<p>
Если у вас есть границы ошибок в вашем приложении (что является хорошей идеей для постепенных сбоев в производстве), они будут повторять рендеринг при следующем редактировании после ошибки рендеринга. Это означает, что наличие границы ошибки может помешать вам всегда возвращаться в состояние корневого приложения. Однако имейте в виду, что границы ошибок не должны быть слишком детальными. Они используются React в производственной среде и всегда должны разрабатываться намеренно.
</p>

<h2>Ограничения</h2>
<p>
Fast Refresh пытается сохранить локальное состояние React в компоненте, который вы редактируете, но только если это безопасно. Вот несколько причин, по которым вы можете увидеть, что локальное состояние сбрасывается при каждом редактировании файла:
</p>
<p className='list'>
 - Локальное состояние не сохраняется для компонентов класса (только функциональные компоненты и хуки сохраняют состояние).
</p>
<p className='list'>
 - Файл, который вы редактируете, может иметь другие экспорты в дополнение к компоненту React.
</p>
<p className='list'>
 - Иногда файл экспортирует результат вызова компонента более высокого порядка, например higherOrderComponent(WrappedComponent). Если возвращаемый компонент является классом, состояние будет сброшено.
</p>
<p>
По мере того как большая часть вашей кодовой базы перемещается в функциональные компоненты и хуки, вы можете ожидать, что состояние будет сохранено в большем количестве случаев.
</p>

<h2>Подсказки</h2>
<p className='list'>
 - Fast Refresh по умолчанию сохраняет локальное состояние React в функциональных компонентах (и хуках).
</p>
<p className='list'>
 - Иногда вам может потребоваться принудительно сбросить состояние и перемонтировать компонент. Например, это может быть удобно, если вы настраиваете анимацию, которая происходит только при монтировании. Для этого вы можете добавить в // @refresh reset любое место редактируемого файла. Эта директива является локальной для файла и предписывает Fast Refresh перемонтировать компоненты, определенные в этом файле, при каждом редактировании.
</p>
<p className='list'>
 - Вы можете вставлять console.log или вставлять debugger; компоненты, которые редактируете во время разработки.
</p>


<h2>Быстрое обновление и хуки</h2>
<p>
По возможности Fast Refresh пытается сохранить состояние вашего компонента между изменениями. В частности, useState и useRef сохранить их предыдущие значения до тех пор, пока вы не измените их аргументы или порядок вызовов Hook.
</p>
<p>
Хуки с зависимостями, такие как useEffect, useMemo и useCallback - будут всегда обновлятся во время быстрого обновления. Их список зависимостей будет проигнорирован, пока происходит быстрое обновление.
</p>
<p>
Например, при редактировании useMemo(() => x * 2, [x])в useMemo(() => x * 10, [x]), она будет повторно запустить , даже если x (зависимость) не изменилась. Если бы React этого не делал, ваше редактирование не отражалось бы на экране!
</p>
<p>
Иногда это может привести к неожиданным результатам. Например, даже useEffect с пустым массивом зависимостей все равно будет повторно запускаться один раз во время быстрого обновления.
</p>
<p>
Однако написание кода, устойчивого к случайному повторному запуску, useEffect является хорошей практикой даже без Fast Refresh. Это упростит вам введение в него новых зависимостей позже, и это обеспечивается строгим режимом React, который мы настоятельно рекомендуем включить.
</p>
            </div>
        </Docs>
    )
}